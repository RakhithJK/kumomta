<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `crates/libunbound-sys/src/lib.rs`."><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="libunbound_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../static.files/source-script-106908c7a7964ba4.js"></script><script defer src="../../source-files.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../libunbound_sys/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
</pre></div><pre class="rust"><code><span class="comment">/* automatically generated by rust-bindgen 0.66.1 */

</span><span class="attr">#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::unreadable_literal)]
#![allow(clippy::upper_case_acronyms)]
#![allow(rustdoc::broken_intra_doc_links)]

</span><span class="kw">pub const </span>UB_STATS_QTYPE_NUM: u32 = <span class="number">256</span>;
<span class="kw">pub const </span>UB_STATS_QCLASS_NUM: u32 = <span class="number">256</span>;
<span class="kw">pub const </span>UB_STATS_RCODE_NUM: u32 = <span class="number">16</span>;
<span class="kw">pub const </span>UB_STATS_OPCODE_NUM: u32 = <span class="number">16</span>;
<span class="kw">pub const </span>UB_STATS_BUCKET_NUM: u32 = <span class="number">40</span>;
<span class="kw">pub const </span>UB_STATS_RPZ_ACTION_NUM: u32 = <span class="number">10</span>;
<span class="attr">#[doc = <span class="string">&quot; The validation context is created to hold the resolver status,\n validation keys and a small cache (containing messages, rrsets,\n roundtrip times, trusted keys, lameness information).\n\n Its contents are internally defined.&quot;</span>]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ub_ctx {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[doc = <span class="string">&quot; The validation and resolution results.\n Allocated by the resolver, and need to be freed by the application\n with ub_resolve_free().&quot;</span>]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ub_result {
    <span class="attr">#[doc = <span class="string">&quot; The original question, name text string.&quot;</span>]
    </span><span class="kw">pub </span>qname: <span class="kw-2">*mut </span>::std::os::raw::c_char,
    <span class="attr">#[doc = <span class="string">&quot; the type asked for&quot;</span>]
    </span><span class="kw">pub </span>qtype: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; the class asked for&quot;</span>]
    </span><span class="kw">pub </span>qclass: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; a list of network order DNS rdata items, terminated with a\n NULL pointer, so that data[0] is the first result entry,\n data[1] the second, and the last entry is NULL.\n If there was no data, data[0] is NULL.&quot;</span>]
    </span><span class="kw">pub </span>data: <span class="kw-2">*mut *mut </span>::std::os::raw::c_char,
    <span class="attr">#[doc = <span class="string">&quot; the length in bytes of the data items, len[i] for data[i]&quot;</span>]
    </span><span class="kw">pub </span>len: <span class="kw-2">*mut </span>::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; canonical name for the result (the final cname).\n zero terminated string.\n May be NULL if no canonical name exists.&quot;</span>]
    </span><span class="kw">pub </span>canonname: <span class="kw-2">*mut </span>::std::os::raw::c_char,
    <span class="attr">#[doc = <span class="string">&quot; DNS RCODE for the result. May contain additional error code if\n there was no data due to an error. 0 (NOERROR) if okay.&quot;</span>]
    </span><span class="kw">pub </span>rcode: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; The DNS answer packet. Network formatted. Can contain DNSSEC types.&quot;</span>]
    </span><span class="kw">pub </span>answer_packet: <span class="kw-2">*mut </span>::std::os::raw::c_void,
    <span class="attr">#[doc = <span class="string">&quot; length of the answer packet in octets.&quot;</span>]
    </span><span class="kw">pub </span>answer_len: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; If there is any data, this is true.\n If false, there was no data (nxdomain may be true, rcode can be set).&quot;</span>]
    </span><span class="kw">pub </span>havedata: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; If there was no data, and the domain did not exist, this is true.\n If it is false, and there was no data, then the domain name\n is purported to exist, but the requested data type is not available.&quot;</span>]
    </span><span class="kw">pub </span>nxdomain: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; True, if the result is validated securely.\n False, if validation failed or domain queried has no security info.\n\n It is possible to get a result with no data (havedata is false),\n and secure is true. This means that the non-existence of the data\n was cryptographically proven (with signatures).&quot;</span>]
    </span><span class="kw">pub </span>secure: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; If the result was not secure (secure==0), and this result is due\n to a security failure, bogus is true.\n This means the data has been actively tampered with, signatures\n failed, expected signatures were not present, timestamps on\n signatures were out of date and so on.\n\n If !secure and !bogus, this can happen if the data is not secure\n because security is disabled for that domain name.\n This means the data is from a domain where data is not signed.&quot;</span>]
    </span><span class="kw">pub </span>bogus: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; If the result is bogus this contains a string (zero terminated)\n that describes the failure.  There may be other errors as well\n as the one described, the description may not be perfectly accurate.\n Is NULL if the result is not bogus.&quot;</span>]
    </span><span class="kw">pub </span>why_bogus: <span class="kw-2">*mut </span>::std::os::raw::c_char,
    <span class="attr">#[doc = <span class="string">&quot; If the query or one of its subqueries was ratelimited.  Useful if\n ratelimiting is enabled and answer to the client is SERVFAIL as a\n result.&quot;</span>]
    </span><span class="kw">pub </span>was_ratelimited: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; TTL for the result, in seconds.  If the security is bogus, then\n you also cannot trust this value.&quot;</span>]
    </span><span class="kw">pub </span>ttl: ::std::os::raw::c_int,
}
<span class="attr">#[doc = <span class="string">&quot; Callback for results of async queries.\n The readable function definition looks like:\n void my_callback(void* my_arg, int err, struct ub_result* result);\n It is called with\n\tvoid* my_arg: your pointer to a (struct of) data of your choice,\n\t\tor NULL.\n\tint err: if 0 all is OK, otherwise an error occurred and no results\n\t     are forthcoming.\n\tstruct result: pointer to more detailed result structure.\n\t\tThis structure is allocated on the heap and needs to be\n\t\tfreed with ub_resolve_free(result);&quot;</span>]
</span><span class="kw">pub type </span>ub_callback_type = ::std::option::Option&lt;
    <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn</span>(
        arg1: <span class="kw-2">*mut </span>::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: <span class="kw-2">*mut </span>ub_result,
    ),
&gt;;
<span class="attr">#[doc = <span class="string">&quot; no error&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_NOERROR: ub_ctx_err = <span class="number">0</span>;
<span class="attr">#[doc = <span class="string">&quot; socket operation. Set to -1, so that if an error from _fd() is\n passed (-1) it gives a socket error.&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_SOCKET: ub_ctx_err = -<span class="number">1</span>;
<span class="attr">#[doc = <span class="string">&quot; alloc failure&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_NOMEM: ub_ctx_err = -<span class="number">2</span>;
<span class="attr">#[doc = <span class="string">&quot; syntax error&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_SYNTAX: ub_ctx_err = -<span class="number">3</span>;
<span class="attr">#[doc = <span class="string">&quot; DNS service failed&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_SERVFAIL: ub_ctx_err = -<span class="number">4</span>;
<span class="attr">#[doc = <span class="string">&quot; fork() failed&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_FORKFAIL: ub_ctx_err = -<span class="number">5</span>;
<span class="attr">#[doc = <span class="string">&quot; cfg change after finalize()&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_AFTERFINAL: ub_ctx_err = -<span class="number">6</span>;
<span class="attr">#[doc = <span class="string">&quot; initialization failed (bad settings)&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_INITFAIL: ub_ctx_err = -<span class="number">7</span>;
<span class="attr">#[doc = <span class="string">&quot; error in pipe communication with async bg worker&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_PIPE: ub_ctx_err = -<span class="number">8</span>;
<span class="attr">#[doc = <span class="string">&quot; error reading from file (resolv.conf)&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_READFILE: ub_ctx_err = -<span class="number">9</span>;
<span class="attr">#[doc = <span class="string">&quot; error async_id does not exist or result already been delivered&quot;</span>]
</span><span class="kw">pub const </span>ub_ctx_err_UB_NOID: ub_ctx_err = -<span class="number">10</span>;
<span class="attr">#[doc = <span class="string">&quot; The error constants&quot;</span>]
</span><span class="kw">pub type </span>ub_ctx_err = ::std::os::raw::c_int;
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Create a resolving and validation context.\n The information from /etc/resolv.conf and /etc/hosts is not utilised by\n default. Use ub_ctx_resolvconf and ub_ctx_hosts to read them.\n @return a new context. default initialisation.\n \treturns NULL on error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_create() -&gt; <span class="kw-2">*mut </span>ub_ctx;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Destroy a validation context and free all its resources.\n Outstanding async queries are killed and callbacks are not called for them.\n @param ctx: context to delete.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_delete(ctx: <span class="kw-2">*mut </span>ub_ctx);
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Set an option for the context.\n @param ctx: context.\n @param opt: option name from the unbound.conf config file format.\n\t(not all settings applicable). The name includes the trailing &#39;:&#39;\n\tfor example ub_ctx_set_option(ctx, \&quot;logfile:\&quot;, \&quot;mylog.txt\&quot;);\n \tThis is a power-users interface that lets you specify all sorts\n \tof options.\n \tFor some specific options, such as adding trust anchors, special\n \troutines exist.\n @param val: value of the option.\n @return: 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_set_option(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        opt: <span class="kw-2">*const </span>::std::os::raw::c_char,
        val: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Get an option from the context.\n @param ctx: context.\n @param opt: option name from the unbound.conf config file format.\n\t(not all settings applicable). The name excludes the trailing &#39;:&#39;\n\tfor example ub_ctx_get_option(ctx, \&quot;logfile\&quot;, &amp;result);\n \tThis is a power-users interface that lets you specify all sorts\n \tof options.\n @param str: the string is malloced and returned here. NULL on error.\n \tThe caller must free() the string.  In cases with multiple\n \tentries (auto-trust-anchor-file), a newline delimited list is\n \treturned in the string.\n @return 0 if OK else an error code (malloc failure, syntax error).&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_get_option(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        opt: <span class="kw-2">*const </span>::std::os::raw::c_char,
        str_: <span class="kw-2">*mut *mut </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; setup configuration for the given context.\n @param ctx: context.\n @param fname: unbound config file (not all settings applicable).\n \tThis is a power-users interface that lets you specify all sorts\n \tof options.\n \tFor some specific options, such as adding trust anchors, special\n \troutines exist.\n @return: 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_config(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        fname: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Set machine to forward DNS queries to, the caching resolver to use.\n IP4 or IP6 address. Forwards all DNS requests to that machine, which\n is expected to run a recursive resolver. If the proxy is not\n DNSSEC-capable, validation may fail. Can be called several times, in\n that case the addresses are used as backup servers.\n\n To read the list of nameservers from /etc/resolv.conf (from DHCP or so),\n use the call ub_ctx_resolvconf.\n\n @param ctx: context.\n\tAt this time it is only possible to set configuration before the\n\tfirst resolve is done.\n @param addr: address, IP4 or IP6 in string format.\n \tIf the addr is NULL, forwarding is disabled.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_set_fwd(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        addr: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Use DNS over TLS to send queries to machines set with ub_ctx_set_fwd().\n\n @param ctx: context.\n\tAt this time it is only possible to set configuration before the\n\tfirst resolve is done.\n @param tls: enable or disable DNS over TLS\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_set_tls(ctx: <span class="kw-2">*mut </span>ub_ctx, tls: ::std::os::raw::c_int) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Add a stub zone, with given address to send to.  This is for custom\n root hints or pointing to a local authoritative dns server.\n For dns resolvers and the &#39;DHCP DNS&#39; ip address, use ub_ctx_set_fwd.\n This is similar to a stub-zone entry in unbound.conf.\n\n @param ctx: context.\n\tIt is only possible to set configuration before the\n\tfirst resolve is done.\n @param zone: name of the zone, string.\n @param addr: address, IP4 or IP6 in string format.\n \tThe addr is added to the list of stub-addresses if the entry exists.\n \tIf the addr is NULL the stub entry is removed.\n @param isprime: set to true to set stub-prime to yes for the stub.\n \tFor local authoritative servers, people usually set it to false,\n \tFor root hints it should be set to true.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_set_stub(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        zone: <span class="kw-2">*const </span>::std::os::raw::c_char,
        addr: <span class="kw-2">*const </span>::std::os::raw::c_char,
        isprime: ::std::os::raw::c_int,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Read list of nameservers to use from the filename given.\n Usually \&quot;/etc/resolv.conf\&quot;. Uses those nameservers as caching proxies.\n If they do not support DNSSEC, validation may fail.\n\n Only nameservers are picked up, the searchdomain, ndots and other\n settings from resolv.conf(5) are ignored.\n\n @param ctx: context.\n\tAt this time it is only possible to set configuration before the\n\tfirst resolve is done.\n @param fname: file name string. If NULL \&quot;/etc/resolv.conf\&quot; is used.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_resolvconf(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        fname: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Read list of hosts from the filename given.\n Usually \&quot;/etc/hosts\&quot;.\n These addresses are not flagged as DNSSEC secure when queried for.\n\n @param ctx: context.\n\tAt this time it is only possible to set configuration before the\n\tfirst resolve is done.\n @param fname: file name string. If NULL \&quot;/etc/hosts\&quot; is used.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_hosts(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        fname: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Add a trust anchor to the given context.\n The trust anchor is a string, on one line, that holds a valid DNSKEY or\n DS RR.\n @param ctx: context.\n\tAt this time it is only possible to add trusted keys before the\n\tfirst resolve is done.\n @param ta: string, with zone-format RR on one line.\n \t[domainname] [TTL optional] [type] [class optional] [rdata contents]\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_add_ta(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        ta: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Add trust anchors to the given context.\n Pass name of a file with DS and DNSKEY records (like from dig or drill).\n @param ctx: context.\n\tAt this time it is only possible to add trusted keys before the\n\tfirst resolve is done.\n @param fname: filename of file with keyfile with trust anchors.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_add_ta_file(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        fname: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Add trust anchor to the given context that is tracked with RFC5011\n automated trust anchor maintenance.  The file is written to when the\n trust anchor is changed.\n Pass the name of a file that was output from eg. unbound-anchor,\n or you can start it by providing a trusted DNSKEY or DS record on one\n line in the file.\n @param ctx: context.\n\tAt this time it is only possible to add trusted keys before the\n\tfirst resolve is done.\n @param fname: filename of file with trust anchor.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_add_ta_autr(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        fname: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Add trust anchors to the given context.\n Pass the name of a bind-style config file with trusted-keys{}.\n @param ctx: context.\n\tAt this time it is only possible to add trusted keys before the\n\tfirst resolve is done.\n @param fname: filename of file with bind-style config entries with trust\n \tanchors.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_trustedkeys(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        fname: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Set debug output (and error output) to the specified stream.\n Pass NULL to disable. Default is stderr.\n @param ctx: context.\n @param out: FILE* out file stream to log to.\n \tType void* to avoid stdio dependency of this header file.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_debugout(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        out: <span class="kw-2">*mut </span>::std::os::raw::c_void,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Set debug verbosity for the context\n Output is directed to stderr.\n @param ctx: context.\n @param d: debug level, 0 is off, 1 is very minimal, 2 is detailed,\n\tand 3 is lots.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_debuglevel(ctx: <span class="kw-2">*mut </span>ub_ctx, d: ::std::os::raw::c_int) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Set a context behaviour for asynchronous action.\n @param ctx: context.\n @param dothread: if true, enables threading and a call to resolve_async()\n\tcreates a thread to handle work in the background.\n\tIf false, a process is forked to handle work in the background.\n\tChanges to this setting after async() calls have been made have\n\tno effect (delete and re-create the context to change).\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_async(ctx: <span class="kw-2">*mut </span>ub_ctx, dothread: ::std::os::raw::c_int)
        -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Poll a context to see if it has any new results\n Do not poll in a loop, instead extract the fd below to poll for readiness,\n and then check, or wait using the wait routine.\n @param ctx: context.\n @return: 0 if nothing to read, or nonzero if a result is available.\n \tIf nonzero, call ctx_process() to do callbacks.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_poll(ctx: <span class="kw-2">*mut </span>ub_ctx) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Wait for a context to finish with results. Calls ub_process() after\n the wait for you. After the wait, there are no more outstanding\n asynchronous queries.\n @param ctx: context.\n @return: 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_wait(ctx: <span class="kw-2">*mut </span>ub_ctx) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Get file descriptor. Wait for it to become readable, at this point\n answers are returned from the asynchronous validating resolver.\n Then call the ub_process to continue processing.\n This routine works immediately after context creation, the fd\n does not change.\n @param ctx: context.\n @return: -1 on error, or file descriptor to use select(2) with.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_fd(ctx: <span class="kw-2">*mut </span>ub_ctx) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Call this routine to continue processing results from the validating\n resolver (when the fd becomes readable).\n Will perform necessary callbacks.\n @param ctx: context\n @return: 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_process(ctx: <span class="kw-2">*mut </span>ub_ctx) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Perform resolution and validation of the target name.\n @param ctx: context.\n\tThe context is finalized, and can no longer accept config changes.\n @param name: domain name in text format (a zero terminated text string).\n @param rrtype: type of RR in host order, 1 is A (address).\n @param rrclass: class of RR in host order, 1 is IN (for internet).\n @param result: the result data is returned in a newly allocated result\n \tstructure. May be NULL on return, return value is set to an error\n \tin that case (out of memory).\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_resolve(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        name: <span class="kw-2">*const </span>::std::os::raw::c_char,
        rrtype: ::std::os::raw::c_int,
        rrclass: ::std::os::raw::c_int,
        result: <span class="kw-2">*mut *mut </span>ub_result,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Perform resolution and validation of the target name.\n Asynchronous, after a while, the callback will be called with your\n data and the result.\n @param ctx: context.\n\tIf no thread or process has been created yet to perform the\n\twork in the background, it is created now.\n\tThe context is finalized, and can no longer accept config changes.\n @param name: domain name in text format (a string).\n @param rrtype: type of RR in host order, 1 is A.\n @param rrclass: class of RR in host order, 1 is IN (for internet).\n @param mydata: this data is your own data (you can pass NULL),\n \tand is passed on to the callback function.\n @param callback: this is called on completion of the resolution.\n \tIt is called as:\n \tvoid callback(void* mydata, int err, struct ub_result* result)\n \twith mydata: the same as passed here, you may pass NULL,\n \twith err: is 0 when a result has been found.\n \twith result: a newly allocated result structure.\n\t\tThe result may be NULL, in that case err is set.\n\n \tIf an error happens during processing, your callback will be called\n \twith error set to a nonzero value (and result==NULL).\n @param async_id: if you pass a non-NULL value, an identifier number is\n\treturned for the query as it is in progress. It can be used to\n\tcancel the query.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_resolve_async(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        name: <span class="kw-2">*const </span>::std::os::raw::c_char,
        rrtype: ::std::os::raw::c_int,
        rrclass: ::std::os::raw::c_int,
        mydata: <span class="kw-2">*mut </span>::std::os::raw::c_void,
        callback: ub_callback_type,
        async_id: <span class="kw-2">*mut </span>::std::os::raw::c_int,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Cancel an async query in progress.\n Its callback will not be called.\n\n @param ctx: context.\n @param async_id: which query to cancel.\n @return 0 if OK, else error.\n This routine can return an error if the async_id passed does not exist\n or has already been delivered. If another thread is processing results\n at the same time, the result may be delivered at the same time and the\n cancel fails with an error.  Also the cancel can fail due to a system\n error, no memory or socket failures.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_cancel(ctx: <span class="kw-2">*mut </span>ub_ctx, async_id: ::std::os::raw::c_int) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Free storage associated with a result structure.\n @param result: to free&quot;</span>]
    </span><span class="kw">pub fn </span>ub_resolve_free(result: <span class="kw-2">*mut </span>ub_result);
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Convert error value to a human readable string.\n @param err: error code from one of the libunbound functions.\n \tThe error codes are from the type enum ub_ctx_err.\n @return pointer to constant text string, zero terminated.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_strerror(err: ::std::os::raw::c_int) -&gt; <span class="kw-2">*const </span>::std::os::raw::c_char;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Debug routine.  Print the local zone information to debug output.\n @param ctx: context.  Is finalized by the routine.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_print_local_zones(ctx: <span class="kw-2">*mut </span>ub_ctx) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Add a new zone with the zonetype to the local authority info of the\n library.\n @param ctx: context.  Is finalized by the routine.\n @param zone_name: name of the zone in text, \&quot;example.com\&quot;\n\tIf it already exists, the type is updated.\n @param zone_type: type of the zone (like for unbound.conf) in text.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_zone_add(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        zone_name: <span class="kw-2">*const </span>::std::os::raw::c_char,
        zone_type: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Remove zone from local authority info of the library.\n @param ctx: context.  Is finalized by the routine.\n @param zone_name: name of the zone in text, \&quot;example.com\&quot;\n\tIf it does not exist, nothing happens.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_zone_remove(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        zone_name: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Add localdata to the library local authority info.\n Similar to local-data config statement.\n @param ctx: context.  Is finalized by the routine.\n @param data: the resource record in text format, for example\n\t\&quot;www.example.com IN A 127.0.0.1\&quot;\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_data_add(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        data: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Remove localdata from the library local authority info.\n @param ctx: context.  Is finalized by the routine.\n @param data: the name to delete all data from, like \&quot;www.example.com\&quot;.\n @return 0 if OK, else error.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_ctx_data_remove(
        ctx: <span class="kw-2">*mut </span>ub_ctx,
        data: <span class="kw-2">*const </span>::std::os::raw::c_char,
    ) -&gt; ::std::os::raw::c_int;
}
<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="attr">#[doc = <span class="string">&quot; Get a version string from the libunbound implementation.\n @return a static constant string with the version number.&quot;</span>]
    </span><span class="kw">pub fn </span>ub_version() -&gt; <span class="kw-2">*const </span>::std::os::raw::c_char;
}
<span class="attr">#[doc = <span class="string">&quot; Some global statistics that are not in struct stats_info,\n this struct is shared on a shm segment (shm-key in unbound.conf)&quot;</span>]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ub_shm_stat_info {
    <span class="kw">pub </span>num_threads: ::std::os::raw::c_int,
    <span class="kw">pub </span>time: ub_shm_stat_info__bindgen_ty_1,
    <span class="kw">pub </span>mem: ub_shm_stat_info__bindgen_ty_2,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ub_shm_stat_info__bindgen_ty_1 {
    <span class="kw">pub </span>now_sec: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>now_usec: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>up_sec: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>up_usec: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>elapsed_sec: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>elapsed_usec: ::std::os::raw::c_longlong,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ub_shm_stat_info__bindgen_ty_2 {
    <span class="kw">pub </span>msg: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>rrset: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>val: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>iter: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>subnet: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>ipsecmod: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>respip: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>dnscrypt_shared_secret: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>dnscrypt_nonce: ::std::os::raw::c_longlong,
    <span class="kw">pub </span>dynlib: ::std::os::raw::c_longlong,
}
<span class="attr">#[doc = <span class="string">&quot; per worker statistics.&quot;</span>]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ub_server_stats {
    <span class="attr">#[doc = <span class="string">&quot; number of queries from clients received.&quot;</span>]
    </span><span class="kw">pub </span>num_queries: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries that have been dropped/ratelimited by ip.&quot;</span>]
    </span><span class="kw">pub </span>num_queries_ip_ratelimited: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with a valid DNS Cookie.&quot;</span>]
    </span><span class="kw">pub </span>num_queries_cookie_valid: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with only the client part of the DNS Cookie.&quot;</span>]
    </span><span class="kw">pub </span>num_queries_cookie_client: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with invalid DNS Cookie.&quot;</span>]
    </span><span class="kw">pub </span>num_queries_cookie_invalid: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries that had a cache-miss.&quot;</span>]
    </span><span class="kw">pub </span>num_queries_missed_cache: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of prefetch queries - cachehits with prefetch&quot;</span>]
    </span><span class="kw">pub </span>num_queries_prefetch: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries which are too late to process&quot;</span>]
    </span><span class="kw">pub </span>num_queries_timed_out: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; the longest wait time in the queue&quot;</span>]
    </span><span class="kw">pub </span>max_query_time_us: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; Sum of the querylistsize of the worker for\n every query that missed cache. To calculate average.&quot;</span>]
    </span><span class="kw">pub </span>sum_query_list_size: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; max value of query list size reached.&quot;</span>]
    </span><span class="kw">pub </span>max_query_list_size: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; Extended stats below (bool)&quot;</span>]
    </span><span class="kw">pub </span>extended: ::std::os::raw::c_int,
    <span class="attr">#[doc = <span class="string">&quot; qtype stats&quot;</span>]
    </span><span class="kw">pub </span>qtype: [::std::os::raw::c_longlong; <span class="number">256usize</span>],
    <span class="attr">#[doc = <span class="string">&quot; bigger qtype values not in array&quot;</span>]
    </span><span class="kw">pub </span>qtype_big: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; qclass stats&quot;</span>]
    </span><span class="kw">pub </span>qclass: [::std::os::raw::c_longlong; <span class="number">256usize</span>],
    <span class="attr">#[doc = <span class="string">&quot; bigger qclass values not in array&quot;</span>]
    </span><span class="kw">pub </span>qclass_big: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; query opcodes&quot;</span>]
    </span><span class="kw">pub </span>qopcode: [::std::os::raw::c_longlong; <span class="number">16usize</span>],
    <span class="attr">#[doc = <span class="string">&quot; number of queries over TCP&quot;</span>]
    </span><span class="kw">pub </span>qtcp: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of outgoing queries over TCP&quot;</span>]
    </span><span class="kw">pub </span>qtcp_outgoing: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of outgoing queries over UDP&quot;</span>]
    </span><span class="kw">pub </span>qudp_outgoing: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries over (DNS over) TLS&quot;</span>]
    </span><span class="kw">pub </span>qtls: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries over (DNS over) HTTPS&quot;</span>]
    </span><span class="kw">pub </span>qhttps: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries over IPv6&quot;</span>]
    </span><span class="kw">pub </span>qipv6: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with QR bit&quot;</span>]
    </span><span class="kw">pub </span>qbit_QR: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with AA bit&quot;</span>]
    </span><span class="kw">pub </span>qbit_AA: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with TC bit&quot;</span>]
    </span><span class="kw">pub </span>qbit_TC: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with RD bit&quot;</span>]
    </span><span class="kw">pub </span>qbit_RD: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with RA bit&quot;</span>]
    </span><span class="kw">pub </span>qbit_RA: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with Z bit&quot;</span>]
    </span><span class="kw">pub </span>qbit_Z: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with AD bit&quot;</span>]
    </span><span class="kw">pub </span>qbit_AD: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with CD bit&quot;</span>]
    </span><span class="kw">pub </span>qbit_CD: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with EDNS OPT record&quot;</span>]
    </span><span class="kw">pub </span>qEDNS: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries with EDNS with DO flag&quot;</span>]
    </span><span class="kw">pub </span>qEDNS_DO: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; answer rcodes&quot;</span>]
    </span><span class="kw">pub </span>ans_rcode: [::std::os::raw::c_longlong; <span class="number">16usize</span>],
    <span class="attr">#[doc = <span class="string">&quot; answers with pseudo rcode &#39;nodata&#39;&quot;</span>]
    </span><span class="kw">pub </span>ans_rcode_nodata: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; answers that were secure (AD)&quot;</span>]
    </span><span class="kw">pub </span>ans_secure: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; answers that were bogus (withheld as SERVFAIL)&quot;</span>]
    </span><span class="kw">pub </span>ans_bogus: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; rrsets marked bogus by validator&quot;</span>]
    </span><span class="kw">pub </span>rrset_bogus: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries that have been ratelimited by domain recursion.&quot;</span>]
    </span><span class="kw">pub </span>queries_ratelimited: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; unwanted traffic received on server-facing ports&quot;</span>]
    </span><span class="kw">pub </span>unwanted_replies: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; unwanted traffic received on client-facing ports&quot;</span>]
    </span><span class="kw">pub </span>unwanted_queries: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; usage of tcp accept list&quot;</span>]
    </span><span class="kw">pub </span>tcp_accept_usage: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; expired answers served from cache&quot;</span>]
    </span><span class="kw">pub </span>ans_expired: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; histogram data exported to array\n if the array is the same size, no data is lost, and\n if all histograms are same size (is so by default) then\n adding up works well.&quot;</span>]
    </span><span class="kw">pub </span>hist: [::std::os::raw::c_longlong; <span class="number">40usize</span>],
    <span class="attr">#[doc = <span class="string">&quot; number of message cache entries&quot;</span>]
    </span><span class="kw">pub </span>msg_cache_count: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of rrset cache entries&quot;</span>]
    </span><span class="kw">pub </span>rrset_cache_count: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of infra cache entries&quot;</span>]
    </span><span class="kw">pub </span>infra_cache_count: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of key cache entries&quot;</span>]
    </span><span class="kw">pub </span>key_cache_count: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; maximum number of collisions in the msg cache&quot;</span>]
    </span><span class="kw">pub </span>msg_cache_max_collisions: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; maximum number of collisions in the rrset cache&quot;</span>]
    </span><span class="kw">pub </span>rrset_cache_max_collisions: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries that used dnscrypt&quot;</span>]
    </span><span class="kw">pub </span>num_query_dnscrypt_crypted: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries that queried dnscrypt certificates&quot;</span>]
    </span><span class="kw">pub </span>num_query_dnscrypt_cert: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries in clear text and not asking for the certificates&quot;</span>]
    </span><span class="kw">pub </span>num_query_dnscrypt_cleartext: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of malformed encrypted queries&quot;</span>]
    </span><span class="kw">pub </span>num_query_dnscrypt_crypted_malformed: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries which did not have a shared secret in cache&quot;</span>]
    </span><span class="kw">pub </span>num_query_dnscrypt_secret_missed_cache: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of dnscrypt shared secret cache entries&quot;</span>]
    </span><span class="kw">pub </span>shared_secret_cache_count: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries which are replays&quot;</span>]
    </span><span class="kw">pub </span>num_query_dnscrypt_replay: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of dnscrypt nonces cache entries&quot;</span>]
    </span><span class="kw">pub </span>nonce_cache_count: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries for unbound&#39;s auth_zones, upstream query&quot;</span>]
    </span><span class="kw">pub </span>num_query_authzone_up: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries for unbound&#39;s auth_zones, downstream answers&quot;</span>]
    </span><span class="kw">pub </span>num_query_authzone_down: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of times neg cache records were used to generate NOERROR\n responses.&quot;</span>]
    </span><span class="kw">pub </span>num_neg_cache_noerror: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of times neg cache records were used to generate NXDOMAIN\n responses.&quot;</span>]
    </span><span class="kw">pub </span>num_neg_cache_nxdomain: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries answered from edns-subnet specific data&quot;</span>]
    </span><span class="kw">pub </span>num_query_subnet: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries answered from edns-subnet specific data, and\n the answer was from the edns-subnet cache.&quot;</span>]
    </span><span class="kw">pub </span>num_query_subnet_cache: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of queries served from cachedb&quot;</span>]
    </span><span class="kw">pub </span>num_query_cachedb: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of bytes in the stream wait buffers&quot;</span>]
    </span><span class="kw">pub </span>mem_stream_wait: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of bytes in the HTTP2 query buffers&quot;</span>]
    </span><span class="kw">pub </span>mem_http2_query_buffer: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of bytes in the HTTP2 response buffers&quot;</span>]
    </span><span class="kw">pub </span>mem_http2_response_buffer: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; number of TLS connection resume&quot;</span>]
    </span><span class="kw">pub </span>qtls_resume: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; RPZ action stats&quot;</span>]
    </span><span class="kw">pub </span>rpz_action: [::std::os::raw::c_longlong; <span class="number">10usize</span>],
}
<span class="attr">#[doc = <span class="string">&quot; Statistics to send over the control pipe when asked\n This struct is made to be memcopied, sent in binary.\n shm mapped with (number+1) at num_threads+1, with first as total&quot;</span>]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ub_stats_info {
    <span class="attr">#[doc = <span class="string">&quot; the thread stats&quot;</span>]
    </span><span class="kw">pub </span>svr: ub_server_stats,
    <span class="attr">#[doc = <span class="string">&quot; mesh stats: current number of states&quot;</span>]
    </span><span class="kw">pub </span>mesh_num_states: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; mesh stats: current number of reply (user) states&quot;</span>]
    </span><span class="kw">pub </span>mesh_num_reply_states: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; mesh stats: number of reply states overwritten with a new one&quot;</span>]
    </span><span class="kw">pub </span>mesh_jostled: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; mesh stats: number of incoming queries dropped&quot;</span>]
    </span><span class="kw">pub </span>mesh_dropped: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; mesh stats: replies sent&quot;</span>]
    </span><span class="kw">pub </span>mesh_replies_sent: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; mesh stats: sum of waiting times for the replies&quot;</span>]
    </span><span class="kw">pub </span>mesh_replies_sum_wait_sec: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; mesh stats: sum of waiting times for the replies&quot;</span>]
    </span><span class="kw">pub </span>mesh_replies_sum_wait_usec: ::std::os::raw::c_longlong,
    <span class="attr">#[doc = <span class="string">&quot; mesh stats: median of waiting times for replies (in sec)&quot;</span>]
    </span><span class="kw">pub </span>mesh_time_median: f64,
}
</code></pre></div></section></main></body></html>